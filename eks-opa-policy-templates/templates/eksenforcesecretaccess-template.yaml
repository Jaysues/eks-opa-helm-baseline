apiVersion: templates.gatekeeper.sh/v1beta1
kind: ConstraintTemplate
metadata:
  name: eksenforcesecretaccess
  annotations:
    description: "Controls access to Kubernetes secrets"
spec:
  crd:
    spec:
      names:
        kind: EksEnforceSecretAccess
      validation:
        openAPIV3Schema:
          type: object
          properties:
            allowedRoles:
              type: array
              items:
                type: string
            defaultClusterRoles:
              type: array
              items:
                type: string
            eksClusterRoles:
              type: array
              items:
                type: string
            gatekeeperRoles:
              type: array
              items:
                type: string
            allowedPatterns:
              type: array
              items:
                type: object
                properties:
                  namePattern:
                    type: string
                  allowedVerbs:
                    type: array
                    items:
                      type: string
            requireNamespaceScope:
              type: boolean
  targets:
    - target: admission.k8s.gatekeeper.sh
      rego: |
        package eksenforcesecretaccess

        violation[{"msg": msg, "details": details}] {
          input.review.object.rules[_].resources[_] == "secrets"
          not is_default_cluster_role
          not is_gatekeeper_cluster_role
          not is_eks_managed_cluster_role
          not role_allowed(input.review.object.metadata.name)
          
          msg := sprintf("Role '%v' not allowed to access secrets", [input.review.object.metadata.name])
          details := {
            "role_name": input.review.object.metadata.name,
            "namespace": input.review.object.metadata.namespace,
            "cis_benchmark": "4.1.2",
            "finding_type": "CIS_BENCHMARK_VIOLATION"
          }
        }

        is_default_cluster_role {
          input.review.kind.kind == "ClusterRole"
          metadata := input.review.object.metadata
          is_default_cluster_role_name(metadata.name)
          metadata.labels["kubernetes.io/bootstrapping"] == "rbac-defaults"
        }

        is_default_cluster_role_name(name) {
          name == input.parameters.defaultClusterRoles[_]
        }

        is_default_cluster_role_name(name) {
          startswith(name, "system:")
        }

        is_gatekeeper_cluster_role {
          input.review.kind.kind == "ClusterRole"
          input.review.object.metadata.name == input.parameters.gatekeeperRoles[_]
        }

        is_eks_managed_cluster_role { 
          input.review.kind.kind == "ClusterRole"
          input.review.object.metadata.name == input.parameters.eksClusterRoles[_]
        }

        role_allowed(role) {
          input.parameters.allowedRoles[_] == role
        }

        violation[{"msg": msg}] {
          input.review.object.kind == "Role"
          rule := input.review.object.rules[_]
          resource := rule.resources[_]
          resource == "secrets"
          not matches_allowed_pattern(rule)
          msg := sprintf("Secret access in role %v does not match allowed patterns", [input.review.object.metadata.name])
        }

        matches_allowed_pattern(rule) {
          pattern := input.parameters.allowedPatterns[_]
          re_match(pattern.namePattern, rule.resourceNames[_])
          verbs_allowed(rule.verbs, pattern.allowedVerbs)
        }

        verbs_allowed(actual, allowed) {
          count({v | v := actual[_]; not allowed[_] == v}) == 0
        } 